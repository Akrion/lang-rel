// https://github.com/lezer-parser/python/blob/main/src/python.grammar

@precedence {
  cond,
  trail,
  power @right,
  prefix,
  times @left,
  plus @left,
  shift @left,
  bitand @left,
  xor @left,
  bitor @left,
  compare @left,
  and @left,
  or @left
}

@top Rel { (statement)+ }

@skip { space | Comment | BlockComment }

OutputDefinition {
  kw<"def"> kw<"output"> AssignOp{"="} VariableName
}

TypeDef { ":" test }

statement[@isGroup=Statement] { smallStatement }

smallStatement {
  AssignStatement { expressions TypeDef? (AssignOp{"="} VariableName)+ } |
  InlineStatement { At kw<"inline"> VariableName } |
  DefineStatement { kw<"def"> AssignOp{"="} VariableName } |
  ModuleStatement |
  IfStatement |
  OutputDefinition |
  CompareOp |
  UpdateOp
}

ModuleStatement {
  kw<"module"> VariableName
  Body
  kw<"end">
}

expressions { commaSep<"*" expression | test> }

commaSep<expr> { expr ("," expr)* ","? }

elseClause { kw<"else"> Body }

IfStatement {
  kw<"if"> testNamed Body
  (kw<"then"> testNamed? Body)*
  elseClause?
  kw<"end">
}

Body { statement+ }

test {
 testInner |
 ConditionalExpression { testInner !cond kw<"if"> testInner kw<"else"> test }
}

testNamed {
  test | NamedExpression { test AssignOp{":="} test }
}

testInner { binaryTest | unaryTest | expression }

binaryTest[@name="BinaryExpression"] {
  testInner !or kw<"or"> testInner |
  testInner !and kw<"and"> testInner
}

unaryTest[@name="UnaryExpression"] { kw<"not"> testInner }

expression[@isGroup=Expression] {
  WithExpression |
  VariableName |
  Number |
  String |
  @specialize[@name=Boolean]<identifier, "true" | "false">
}

WithExpression { kw<"with"> VariableName kw<"use"> VariableName}

// ArgList { "(" commaSep<argument>? ")" }

// argument { test compFor? | VariableName AssignOp{"=" | ":="} test | "**" test | "*" test }

// compFor {
//   kw<"for"> commaSep<expression> kw<"in"> testInner (compFor | compIf)?
// }

// compIf {
//   kw<"if"> testInner (compFor | compIf)?
// }

VariableName { identifier }

// PropertyName { word }

kw<term> { @specialize[@name={term}]<identifier, term> }

@tokens {
  CompareOp { "<" | ">" | $[<>=!] "=" | "<>" }

  UpdateOp { ($[+\-@%&|^] | "<++" | "++>" | "*") "=" }

  identifierChar { std.asciiLetter | $[_\u{a1}-\u{10ffff}] }

  word { identifierChar (std.digit | identifierChar)* }

  identifier { word }

  Number {
    (std.digit ("_" | std.digit)* ("." ("_" | std.digit)*)? | "." std.digit ("_" | std.digit)*)
      (("e" | "E") ("+" | "-")? ("_" | std.digit)+)? |
    std.digit ("_" | std.digit)* "n" |
    "0x" (std.digit | $[a-fA-F] | "_")+ "n"? |
    "0b" $[01_]+ "n"? |
    "0o" $[0-7_]+ "n"?
  }

  String {
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"?
  }

  Comment { "//" ![\n\r]* }

  BlockComment { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  space { ($[ \t\f] | "\\" $[\n\r])+ }

  At { "@" }

  "..."[@name=Ellipsis]

  "("[@export=ParenL] ")"
  "["[@export=BracketL] "]"
  "{"[@export=BraceL] "}"

  "." "," ";" ":" "@" "*" "**"
}
